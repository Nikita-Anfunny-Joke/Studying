"""
Здесь я буду изучать Python и машинное обучение
"""

#### ТИПЫ ДАННЫХ
""" НЕИЗМЕЯЕМЫЕ ТИПЫ ДАННЫХ
1) строка - str
2) целые числа - int
3) числа с 'плавающей' точкой - float
4) кортежи - tuple
5) логические типы данных - bool
"""
my_string = "Hello"
print(type(my_string))

number = 3
print(type(number))

float_number = 3.141592
print(type(float_number))

my_tuple = ("Strings", "Numbers", "Tuples", "Boolean")
print(type(my_tuple))

logical_val = True
print(type(logical_val))

logical_val = False
print(type(logical_val))

""" ИЗМЕНЯЕМЫЕ ТИПЫ ДАННЫХ
1) лист - list
2) словарь - dict
3) множества - set
"""

my_list = ["Strings", "Numbers", "Tuples", "Boolean"]
print(type(my_list))

my_dict = {
"Lists": "mutable",
"Strings": "immutable",
"Numbers": "immutable"
}

print(type(my_dict))

my_set = {"Strings", "Numbers", "Tuples", "Boolean"}
print(type(my_set))

""" ЛОГИЧЕСКИЕ ОПЕРАТРЫ
true AND true = true
true AND false = false

true OR false = true

NOT true = false
false OR NOT false = true

() > not > and > or
"""

# КОГДА ПРИМЕНЯТЬ ОПРЕДЕЛЕННЫЙ ТИП ДАННЫХ??

''' LIST лист
Списки стоит применять, когда мы хотим класть много данных в одно логическое место.
Например, список заказов одного клиента.
Если хотим добавлять элементы, следить за их взаимным порядком и удалять — самое то.
'''

""" TUPLE кортеж
Кортежи применяют когда требуются удобства списков, но в то же время важна неизменяемость данных.
"""

'''SET множества
Если нужно получить только уникальные элементы и порядок элементов не важен.
Самый частый на практике кейс.
Если нужно узнать пересечение и прочие операции над множествами.
'''

""" DICT словарь
Коллекция, которая упорядочена** и изменяема. Нет повторяющихся элементов.
"""

#### ФУНКЦИИ

'''
Функция – это мини-программа внутри вашей основной программы, которая делает какую-то одну понятную вещь.
Вы однажды описываете, что это за вещь, а потом ссылаетесь на это описание.
'''

# Функция, которая выводит на экран 'Hello Ivan'
def say_hello():
    print('Hello Ivan')

say_hello()

'''
Чтобы она возвращала значение после вызова,
добавьте ключевое слово return в теле функции перед переменной,
которую хотите вернуть
'''

# Функция, которая определяет четное число или нет
def is_even(number):
    if number % 2 == 0:
        return True
    else:
        return False

print(is_even(3))
print(is_even(4))

#### CALL STACK

'''
Одна функция в ходе выполнения может вызывать другую функцию.
'''
def inner_func(m):
    print("считаем а")
    a = m // 2
    a = a * a
    print("возвращаем a")
    return a
def outer_func(num):
    num += 2
    print(num)
    print("входим во внутреннюю функцию")
    k = inner_func(num)
    print("печатаем k")
    print(k, num)

outer_func(20)

# 22
# входим во внутреннюю функцию
# считаем а
# возвращаем а
# печатаем k
# 121 22

#### СРЕЗЫ

'''
Срезы позволяют обрезать список, взяв лишь те элементы, которые нужны.
Они работают по следующей схеме: list[НАЧАЛО:КОНЕЦ:ШАГ]
'''
a = [1, 5, 8, 3, 4]
a[2:4]  # забрать элементы с третьего по пятый НЕ включительно (третий, четвертый)
# Результат
#[8, 3]

# если опустить первый аргумент, то будет от начала списка
a[:4]  # по пятый НЕ включительно
# Результат
#[1, 5, 8, 3]

# если опустить второй аргумент, то будет до конца списка
a[2:]
# Результат
#[8, 3, 4]

# нумеровать можно отрицательными числами
# ниже описывается пример, как это будет считаться
# [1, 5, 8, 3, 4]
#  0  1  2  3  4
# -5 -4 -3 -2 -1
#a[1:len(a)-1]
a[1:-1]  # правый конец не включается, поэтому отдаст список со второго по предпоследний элемент
# Результат
#[5, 8, 3]

# Может ничего не попасть
a[-1:-2]
# Результат
#[]

a[-2:-1]
# Результат
#[3]

# Есть еще третий аргумент - это шаг. Его можно пропустить
a[1:4:2]
# Результат
#[5, 3]

a[::2]  # выдаст первый, третий и т.д.
# Результат
#[1, 8, 4]

a[::-1]  # каждый "минус первый" - это каждый первый, только в обратном порядке,
# т.е. просто развернет лист
# Результат
#[4, 3, 8, 5, 1]

# развернет и через один
a[::-2]
# Результат
#[4, 8, 1]

a[3:1:-1]  # учтите, что в квадратных скобках индексы задаются от неразвернутого листа
# тут левый конец больше правого - при обратном порядке это нормально
# Результат
#[3, 8]

# но при прямом это не сработает
# (от четвертого элемента до второго при движении вправо нет ничего)
a[3:1]
# Результат
#[]


#### РАБОТА С ТЕКСТОМ

'''
print('HeLlO'.lower())
print('hello'.upper())
hello
HELLO

print('hello'.islower())
print('HELLO'.isupper())
True
True

'hello llevo'.replace('ll', 'mm')
'hemmo mmevo'

'Сегодня чудесный день'.split()
['Сегодня', 'чудесный', 'день']

'   После опознания текста много    пробелов     '.strip()
'После опознания текста много    пробелов'
'''

# КЛАССЫ И ООП

# class - Ключевое слово
# Auto - Название класса(записывается в CamelCase(СлитноКаждоеСловоСЗаглавной))
# : - даёт понять python, что дальше идёт блок кода
# @dataclass - упрощает создание класса в нашем случае

from dataclasses import dataclass
@dataclass
class Auto:
    color: str
    manufacturer: str
    series: str
    fuel_type: str


